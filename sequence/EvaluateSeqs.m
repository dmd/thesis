function [alleffs, BestSeqs, bestEs, BestVec, BestFiltVec, allseqs, matchseqs] = EvaluateSeqs(par,SimMat)
% Evaluate mapping of sequence labels for maximum efficiency
% given a set of similarity matrices.
%
% Daniel M. Drucker <ddrucker@psych.upenn.edu>
%
% par.perms         = how many permutations to try
% par.TrialDuration = length of stimulus in secs
% par.HRFLength     = length of convolving function in secs
% par.ResolutionHz  = resolution to convolve at in Hz
% par.seqfile       = file generated by "seqgen -q"
% par.seq           = if present, sequence (ignore seqfile)
% par.HRFFile       = convolution function file
% par.HRFFileHz     = resolution of convolving function file in Hz
% par.BlankLength   = number of blanks to insert for each blank
% par.numSeqs       = number of top n sequences to return
% par.weneed        = how many matching seqs to return



nSimMats = size(SimMat,3);

if ~isfield(par,'seq') && ~isfield(par,'dontpermute')
    % get the output from seqgen
    raw=csvread(par.seqfile);
    PSeqs=raw(:,2:end-2); % remove doubled first

    four=raw(:,end-1);
    nine=raw(:,end);
    PSeqs=PSeqs';

    nine=ztransform(nine);
    four=ztransform(four);

    % plot(nine,four,'+');
    % xlabel('Equation 4 criterion - ORDER (sd)');
    % ylabel('Equation 9 criterion - TRENDS (sd)');

    % identify the sequence with the lowest combined Criterion 4 and 9

    Combo=nine+four;
    PSeq=PSeqs(:,Combo==min(Combo));
    PSeq=PSeq(:,1);
    PSeq=PSeq-min(PSeq);
else
    PSeq=par.seq;
end
PSeq(PSeq<0)=PSeq(PSeq<0)+max(PSeq).*2+1;
p=max(PSeq)-min(PSeq);
BlankElements=0;  % potentially you can specify multiple blanks

blanksinseq = sum(ismember(PSeq,BlankElements));

% Load the Endogenous Filter
if isfield(par,'dontexpand')
    blanksinseq=0;
end
EndoLength=(length(PSeq)-1+blanksinseq)*par.TrialDuration*par.ResolutionHz;
EndogenousFilter=readref(par.HRFFile);
if par.ResolutionHz ~= par.HRFFileHz
    EndogenousFilter=SincInterpo(EndogenousFilter,par.ResolutionHz./par.HRFFileHz);
end
EndogenousFilter=[EndogenousFilter ; zeros(EndoLength-length(EndogenousFilter),1)];
EndogenousFilter=NormMag(mncn(EndogenousFilter));
EndogenousKernel=fft(EndogenousFilter);
EndogenousKernel(1)=1; % set DC component to pin amplitude

if size(SimMat,1) ~= p
    error('Similarity matrix is not of correct size');
end


%%%%%%%%%%%%
%%%%%%%%%%%% NOW THE REAL WORK BEGINS
%%%%%%%%%%%%

alleffs=zeros(nSimMats,par.perms);
allseqs=zeros(length(PSeq)+blanksinseq,par.perms);

maxE=0;

% create a place to put the permed pseq
PermedPSeq=zeros(length(PSeq),1);

alreadydid=[];

if p+1 < 10
    permstotry=perms(1:p+1)-1;
    permstotry=shufflerows(permstotry);
    permstotry=permstotry(ismember(permstotry(:,1),BlankElements),:); % don't shuffle the blank
    if par.perms > length(permstotry)
        par.perms = length(permstotry);
    end
    permstotry=permstotry(1:par.perms,:);
    fprintf('generated all perms to try\n');
end

if isfield(par,'dontpermute')
    par.perms=1;
end

for Perm = 1:par.perms
    goodchoice=false;

    % Permute the assignment of stimuli to labels
    if ~isfield(par,'dontpermute')
        if p+1 < 10
            Relabel=permstotry(Perm,:);
        else
            while ~goodchoice
                Relabel=randperm(p+1)-1;
                if ismember(Relabel(1),BlankElements)
                    continue;
                end
                if  ~ismember(str2double(sprintf('%d',Relabel)),alreadydid) 
                    % we must not have already tried this permutation
                    % the first item must be a blank
                    goodchoice = true;
                    alreadydid=[alreadydid;str2double(sprintf('%d',Relabel))]; % the sprintf nonsense makes the ismember go faster
                else
                    fprintf('.');
                end
            end
        end


        % iterate through all the values and put the new value
        % in as assigned by relabel in the spot indicated by PSeq
        for i = 0:p
            PermedPSeq(PSeq==i)=Relabel(i+1);
        end
    else
        PermedPSeq=PSeq;
    end
    % set the blank trials to zero and expand
    if ~isfield(par,'dontexpand')
        QSeq=zeros(length(PSeq)+blanksinseq,1);

        % StartSeq is the permuted PSeq. we walk through it, adding its
        % elements to QSeq. if we encounter an element that is a member
        % of BlankElements, instead of adding that element to QSeq we add
        % BlankLength zeros instead.

        pointer=1;
        for j=1:length(PSeq)
            if find(PermedPSeq(j)==BlankElements)
                pointer=pointer+par.BlankLength;
            else
                QSeq(pointer) = PermedPSeq(j);
                pointer=pointer+1;
            end
        end
    else
        QSeq = PermedPSeq;
    end

    NewLength=length(QSeq)-1;  % differences vector is 1 smaller
    TempVec = zeros(NewLength,nSimMats);

    for j=1:NewLength

        if QSeq(j:j+1) ~= 0
            TempVec(j,:) = SimMat(QSeq(j),QSeq(j+1),:);
        end
        if QSeq(j) == QSeq(j+1)
            TempVec(j,:) = -88; % RepeatStim (77,88,99 are magic flags)
        end
        if QSeq(j) == 0
            TempVec(j,:) = -99; % NewStim
        end
        if QSeq(j+1) == 0
            TempVec(j,:)= -77; % BlankStim
        end
    end
    Stims   =   TempVec  > -76 ;

    FullVec=zeros(NewLength,nSimMats);
    FullVec(Stims)=reshape(TempVec(Stims),length(TempVec(Stims))/nSimMats,nSimMats);

    % individually mean center
    for n=1:nSimMats
        if range(FullVec(:,n)) ~= 1, FullVec(:,n)=mncnleavezeros(FullVec(:,n)); end
    end

    Vec=Geoffcongrid(FullVec,length(FullVec)*par.TrialDuration*par.ResolutionHz);

    FiltVec=ifft(fft(Vec).*repmat(EndogenousKernel,1,nSimMats));
    E=sum(FiltVec.^2)./sum(Vec.^2);
    alleffs(:,Perm)=E;
    allseqs(:,Perm)=QSeq;
    %fprintf('ssqE %0.4f\n',eucsum(E'));
    if eucsum(E') > maxE
        maxE = eucsum(E');
        maxeffidx = Perm;
        BestVec=Vec;
        BestFiltVec=FiltVec;
        fprintf('new best: '); fprintf('ssqE %0.2f\t',eucsum(E')); fprintf('%0.2f ',E);   fprintf('\n');
    end

    if mod(Perm,1000) == 0
        fprintf('--- (%2.0f%% done) ---\n',floor(100*Perm/par.perms));
    end

end


[sortedsumofeffs,sortedsumofeffs_index] = sort(eucsum(alleffs));

bestEs = alleffs(:,sortedsumofeffs_index(end-par.numSeqs+1:end));
BestSeqs = allseqs(:,sortedsumofeffs_index(end-par.numSeqs+1:end));


% we want to choose the best par.weneed sequences that all start with the
% same number. to do this we will go through all the sequences from best to
% worst; as we go, we make a note of what each sequence starts with by
% incrementing a counter in COUNTINIT, and we store the sequence in
% SEQSTORE in a bucket #'d the start of the sequence (+1).
% when we have par.weneed of something, we stop, and use them.

seqs=fliplr(BestSeqs); % order them best to worst
stims=length(unique(seqs(:,1)));
seqlen=size(seqs,1);
countinit=zeros(stims,1); % keep track of them here
seqstore=zeros(seqlen,stims,par.weneed); % store them here
i=1;
first_of_sequence=1;

while countinit(first_of_sequence+1) < par.weneed
    % loop until we have par.weneed of SOMETHING
    first_of_sequence=seqs(1,i);  % arg stupid matlab starting counting at 1
    countinit(first_of_sequence+1) = countinit(first_of_sequence+1) + 1;
    seqstore(:,first_of_sequence+1,countinit(first_of_sequence+1)) = seqs(:,i);
    i=i+1;
end
matchseqs=squeeze(seqstore(:,first_of_sequence+1,:));

if nSimMats == 2
    % if we can, why not give some eye candy
    plot(alleffs(1,:),alleffs(2,:),'.k');
    title(sprintf('Efficiencies - %d permutations',Perm));
    xlabel('covariate 1');
    ylabel('covariate 2');
    text(bestEs(1,end),bestEs(2,end),sprintf('%0.2f, %0.2f',bestEs(1,end),bestEs(2,end)),'FontSize',15);
end

fprintf('Best was found on permutation %d of %d\n',maxeffidx,Perm);



    function s=eucsum(p)
        s=sqrt(sum(p.^2,1));
    end

end
